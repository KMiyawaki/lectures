# Python(2)

[python/Home](Home.md)

---

## 前回の復習

* pythonとは
  * オブジェクト指向
  * 便利なクラス達
    * リスト(配列)、辞書、文字列
* 各種制御構造
* `if,for, while`
* インデントによるブロックの範囲指定
* ファイルの読み書き

## 関数の定義

* `def`を使う
* ブロックはインデントで
* 別ファイルに定義すると
  * `import file名`
  * 呼び出しは,`file名.関数名`
* （例）`hoe.py`

```python
def hello():
    print("Hello world")
```

* 使い方その1

```python
import hoe
hoe.hello()
```

* 使い方その2

```python
from hoe import hello
hello()
```

## プログラムの使いまわし

* ある作業をするプログラムを書く
  * 単体でテスト、本番でも使用
* そのプログラムを使用した更に上位のプログラム
  * 別プロセスとして呼び出しは面倒
    * データの送受信を考えないといけない
  * 関数として呼び出し
* **ひとつのプログラムを両方の目的に使いたい**

## 書き方の作法

* 単体でも、関数としても使えるように
* 全体を関数として定義
* プログラムの最後におまじない
* 特殊な変数`__name__`を利用

```python
def work():
    作業内容のプログラム

if __name__ == "__main__":
    work()
```

## 例外

* 実行途中でエラーが出るとどうなるか
  * 通常はエラーメッセージを表示して停止
  * 内容によっては止まって欲しくない
* エラーの発生を捕捉し適切な対処を書く

```python
fn = "filename.txt"
try:
    fp=open(fn, "r") # この範囲で起きる例外を監視
except IOError: # この名前の例外が起きたら
    print("Cannot open file %s" % fn) # ここを実行
print("next step")
```

## 例外の使い方

* 想定されるエラーの処理
  * 対応していない入力
  * ファイルが存在しない
  * 適切に対処して通常処理に戻す
* 独自の例外を発生
  * `raise`
  * 処理を途中で止めて別のことをしたいとき
  * タイムアウトとか
* **うまく使うとそれなりに便利**

## 独自クラスの設計

* クラスは自分で定義が可能
  * 組み込みクラス(辞書とかリストとか)だけではない
  * 組み込みクラスだけでもプログラムは書けますが
* クラスを定義すると
  * やりたい事が簡単に記述できる
  * 複数メンバーで分担してプログラム開発ができる
* **是非クラスを使いこなしましょう**

## プログラムの前にすること

* 何をクラスとするかを考える
  * データのかたまりを中心に
  * 機能(仕事内容)で分割
* 各クラスはなるべく独立させる
  * データのやりとりは可能な限りしない
  * 関係する機能はすべてひとつのクラスに
* イメージ的には
  * 仕事全体を人手で行うとして担当を決める
* **役所窓口の係を設定**

## 仕事の依頼方法を決定

* 各クラスのメソッドを決める
  * 何をするメソッドなのか
  * 引数は何か
  * 何が戻ってくるのか
* メソッドの内部は自由にプログラミング
  * 入出力さえ守ればどう作ってもよい
* **経験を積みながら慣れてください**

## クラス設計の例

* テスト結果の集計をするプログラム
  * 元データは Excelで作成( .csv ファイル)
  * 合格者(60点以上)のリストアップ
  * 平均点や合格率等の計算
  * 特別コース学生の成績一覧表の作成
* 何をクラスとするか
  * 成績データを一括管理する「窓口」
  * 平均点の計算や一覧表の作成などもすべておまかせ

## クラスが持つべき機能

* 必要そうな機能(メソッド)をすべて定義
  * 初期化(元ファイルの読み込み)
    * 引数は元ファイル名
  * 学生数の問い合わせ
    * 引数なし。戻り値は数字
  * 個人の成績
    * 引数は学生の名前。戻り値は成績
  * 学生名一覧の取得
    * 引数なし。戻り値は名前の配列
  * 特別コース学生の一覧表作成
    * 引数は出力ファイル名。戻り値はなし

## 定義方法

* `class`ブロックにメソッドを記述
* `TestScore.py`

```python
class TestScore: # クラス定義の開始
    # コンストラクタ
    def __init__(self, fn): # 第一引数は常に self。いわゆる引数は 2個目以降に書く
        self.scores = {} # インスタンス変数
        fp = open(fn, "r") # ローカル変数
        for s in fp:
        a = s.rstrip.split(",")
        self.scores[a[0]] = int(a[1])
        fp.close

    # メソッド群
    def num(self):
        return len(self.scores)

    def names(self):
        return self.scores.keys()

    def score(self, n):
        if n in self.scores:
            return self.scores[n]
        else:
            return None
```

## 使い方

* 生成後はメソッドを呼ぶだけ
* `main.py`

```python
import TestScore # ファイルを読み込み

def work():
    sc = TestScore.TestScore("English.csv") # インスタンスを生成
    print("生徒数 : %d" % sc.num()) # メソッド呼び出し
    for p in sc.names(): # メソッド呼び出し
        print("%s -> %d" % (p, sc.score(p))) # メソッド呼び出し

if __name__ == "__main__":
    work()
```

## 2 教科のときは

* 「点数管理係」を 2人生成
* `EandM.py`

```python
import TestScore
def work():
    eng = TestScore.TestScore("English.csv") # 英語管理係
    math = TestScore.TestScore("Math.csv") # 数学管理係
    for p in eng.names():
        s = (eng.score(p) + math.score(p)) / 2.0 # 英語の点と数学の点を取得する。
        print("%s : %d" % (p, s))
if __name__ == "__main__":
    work()
```

## 実際に作ってみましょう

* 作成するシステム: 音声対話部分
  * 音声認識はせずキーボードから入力
  * 中身を解析し意図を抽出するまで
  * 返事や対話は行いません
* どんなアルゴリズムなのか

## スロットを埋めていく方法

* 必要な(抽出すべき)情報をリストアップ
  * 項目ごとにスロットを準備
  * 各スロットには入る可能性のある単語リストを想定
* 発話中からスロットに対応する単語を抽出
* 空きスロットを問いかける応答を生成

* スロットの構造

| 項目    | 値   |
|------   | ---- |
| 種類    | チーズバーガー |
| 個数    | 1個 |
| 店内か? |     |

* 対話例
  * チーズバーガー を1個ください
    * この段階では店内かどうかのスロットがまだ埋まっていない。
  * お持ち帰りですか?

## 今回は

* スロット形状等は別ファイルで定義
  * タスクの名称
  * スロットの数と名称
  * 登録単語一覧
* 複数のタスクから最適な物を選択
  * 入力をそれぞれのタスクに埋めてみる
  * 最も値が埋まったタスクを選択
    * 同率の場合はスロット数の多いタスクを選択
  * その内容を表示して終わり

## タスクの定義ファイル例

* `BRING_ITEM.txt`

```text
BRING_ITEM （タスク名）
LOCATION （スロット名） : kitchen living dining （単語リスト）
WHO : Ken Mike Elizabeth John Andrew Robert
ITEM : coffee tea apple
(この例は3スロット)
```

## どうクラスを設計するか

* タスク管理係を作成
  * 1 つのタスクに 1 人の管理係
* 各タスク管理係はさらにスロット管理係を雇用する。
  * 個別のスロットの処理はそちらにまかせる。

## 全体のアルゴリズム

* 定義ファイルリストを取得し、それぞれに対応したタスク管理係を生成
* 以下繰り返し
  * すべてのタスクでスロットの中身を空に
  * キーボードから入力
  * 入力文をそれぞれの管理係に与え、スロットに埋めさせる
  * スロットの埋まり率の高いタスクを選択
  * 同率の場合はスロット数の多いタスクを選択
  * 選択されたタスクの中身を表示

## タスク管理係がすること

* 初期化
  * `Task.Task("file.txt")`
    * 戻り値：なし
    * 引数：タスクファイル名
* タスク名を答える
  * `task_name()`
    * 戻り値：文字列
* スロット数を答える
  * `num_slot()`
    * 戻り値：整数
* 値を埋める
  * `fill("bring coffee")`
    * 戻り値：なし
    * 引数：入力文
* スロットの埋まり率を答える
  * `fill_rate()`
    * 戻り値：実数
* 現状の結果を答える
  * `result()`
    * 戻り値：スロット名をキー、スロットの値をvalueとした辞書値が空の場合は`None`
* スロットの値を空にする
  * `clear()`
    * 戻り値：なし

## みんなで協力してシステムを完成させましょう

* 分担
  * `Task.py`を作るグループ
  * `Slot.py`を作るグループ
  * [`main.py`](./python_02/main.py)は各自ダウンロード
* 実習内容
* スロット管理係の仕事を定義
* グループごとにプログラムを実装
* 3 つあわせて、テスト
* ダウンロードファイル
  * [音声認識結果のサンプルファイル](./python_02/input_sample.txt)
  * [タスク定義ファイルの例](./python_02/task_list.tar.gz)

---

[python/Home](Home.md)
